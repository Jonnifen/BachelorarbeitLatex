\subsection{Datenbankentwurf und Normalisierung}
\label{subsec:datenbankentwurf-und-normalisierung}
%------------------------------------------------------------------------------------------------------
In diesen Unterkapiteln werden das grundlegende Wissen zu Datenbanken vermittelt und der Erstellungsablauf erläutert.
Außerdem werden zwei Methoden zum Einbinden in die Applikation aufgezeigt.

Datenbanken sind strukturierte Zusammenstellungen von Daten, die elektronisch gespeichert und verwaltet werden.
Ihr Hauptziel ist es, große Datenmengen strukturiert zu speichern, den Zugriff zu optimieren und die Integrität der Daten zu gewährleisten.
Datenbanken haben im Vergleich zu anderen Dateisystemen Mechanismen, die mehreren Benutzern die parallele Nutzung ermöglichten,
sowie redundante Datenhaltung vermeiden und die effiziente Abfragen über spezielle Sprachen wie die \ac{SQL} ermöglichen.\cite*[6]{Fuchs2021}

In der folgen werden die Hauptanforderungen an Datenbanken bzw. Datenbankmanagementsysteme kurz zusammengefasst:  \cite*[7]{Herrmann2018},\cite*[6]{Fuchs2021}
\begin{itemize}
\item Datenunabhängigkeit: Speicherung unabhängig von Programmen und Plattformen
\item
Benutzerfreundlichkeit: Einfache Sprachen und grafische Oberflächen
\item
Mehrfachzugriff: Gleichzeitiger Zugriff für autorisierte Benutzer
\item
Flexibilität: Wahlfreier Zugriff und fortlaufende Verarbeitung
\item
Effizienz: Kurze Zeiten für Abfragen, Änderungen und Ergänzungen
\item
Datenschutz: Zugriff nach Benutzergruppen beschränkt
\item
Datensicherheit: Schutz vor Fehlern und Ausfällen
\item
Datenintegrität: Vollständige, korrekte und widerspruchsfreie Speicherung
\item
Redundanzfreiheit: Daten nur einmal speichern, Redundanz vermeiden
\end{itemize}



%------------------------------------------------------------------------------------------------------
\subsubsection{Datenbankstruktur}
%------------------------------------------------------------------------------------------------------

Die Struktur der Datenbank legt fest, wie das Datenbanksystem organisiert ist und wie die Datenelemente angeordnet sind.
Das Grundprinzip relationaler Datenbanken sind im Grunde Tabellen und die Beziehungen zwischen diesen.
Die Hauptbestandteile sind: \cite*[35]{Gadatsch2019}

\begin{itemize}
\item Tabellen – das grundlegende Element, welches Daten in Zeilen (Tupeln) und Spalten (Attributen) strukturiert.
\item Ein Datensatz in einer Tabelle wird durch Primärschlüssel (Primary Keys) eindeutig identifiziert.
\item Schlüssel aus anderen Tabellen (Foreign Keys): Tabellenverknüpfung, um die referenzielle Integrität zu gewährleisten.
\item Indizes: Datenstrukturen, die das Beschleunigen von Abfragen ermöglichen.
\item Views: Sie sind virtuelle Tabellen und beruhen auf den Ergebnissen von Abfragen.
\item Constraints: Vorgaben zur Gewährleistung der Datenintegrität (z. B. Wertebereiche, Pflichtfelder oder Dopplungen).
\end{itemize}
\textit{%------------------------------------------------------------------------------------------------------
}\subsubsection{Datenintegrität und Normalisierung}
\textit{%------------------------------------------------------------------------------------------------------
}Ein methodischer Ansatz zur Reduzierung von Redundanzen und Anomalien ist die Normalisierung.
Der Prozess erfolgt schrittweise durch die Normalformen, die durch Indizes (1NF, 2NF, 3NF, BCNF) definiert sind.
Alle Normalformen haben spezifische Arten von Datenanomalien zum Ziel: \cite*[38-41]{Gadatsch2019}

\begin{itemize}

\item 1. Normalform (1NF): Beseitigung mehrfacher Werte innerhalb einer Zelle.
\item 2. Normalform (2NF): Beseitigung partieller Abhängigkeiten.
\item 3. Normalform (3NF): Beseitigung transitiver Abhängigkeiten.

\end{itemize}

Die Gewährleistung, dass Daten korrekt, konsistent und vollständig sind,
fällt unter das Konzept der Datenintegrität.
Sie wird erzielt durch: \cite*[38-41]{Gadatsch2019}

\begin{itemize}
\item
Entity-Integrität (eindeutige Primärschlüssel).
\item
Referentielle Integrität (gültige Fremdschlüsselverweise).

\item Domänenintegrität (gültige Wertebereiche und Datentypen).
\item Entity-Integrität (eindeutige Primärschlüssel).
\item Referentielle Integrität (gültige Fremdschlüsselverweise).
\item Integrität der Domäne (gültige Wertebereiche und Datentypen).

\end{itemize}

\textit{%------------------------------------------------------------------------------------------------------
}\subsubsection{Vorgehen zur Erstellung der Datenbank}
\textit{%------------------------------------------------------------------------------------------------------
}Bei der Erstellung einer Datenbank sollte nach folgendem Schema vorgegangen werden.
Bei diesem Schema gilt es, sowohl technische als auch konzeptionelle Aspekte zu berücksichtigen: \cite*[9-11]{Herrmann2018}

\begin{enumerate}

\item
Anforderungsanalyse

Zuerst wird im Hinblick auf das Geschäftsumfeld bestimmt, welchen konkreten Zweck die Datenbank erfüllen soll.
Hierbei ist die Zweckbestimmung entscheidend, da sie festlegt, welche Daten als relevant gelten.
Der Konzeptvorschlag, der das Projektziel definiert und die Vorgehensweise umreißt, ist das Ergebnis.
\begin{itemize}

\item
Festlegung der fachlichen und technischen Voraussetzungen.
\item
Bestimmung der relevanten Datenquellen und -formate.
\item
Definition von Integritäts- und Sicherheitsanforderungen.

\end{itemize}

\item
Konzeptionelles Datenmodell

Es soll das geschäftliche Umfeld betrachtet werden.
Die bestehenden Objekte (z. B. Reports mit Materialnummer, Datum, Version), deren Attribute sowie die Beziehungen und Einschränkungen zwischen diesen Objekten.
Das Entity-Relationship-Modell (ERM) nach Chen oder das PrecisedERM (PERM) werden häufig zur Modellierung verwendet.
Der konzeptionelle Entwurf ist die Grundlage für die nächste Phase und dient als Diskussionsbasis.
\begin{itemize}

\item Die Entwicklung eines Entity-Relationship-Modells (ERM), das die reale Welt in Entitäten, Attribute und Beziehungen abbildet.
\item Die Einbeziehung von Kardinalitäten (1:1, 1:n, n:m).

\end{itemize}

\item
Logisches Datenmodell

Der konzeptionelle Entwurf wird in einen logischen Entwurf umgewandelt, der die fachlichen Konzepte in ein datenbanktechnisches Format überführt.
In der Regel kommt das Relationenmodell zum Einsatz, welches die Daten in Form von Tabellen organisiert.
Transformationsregeln garantieren, dass Beziehungen und Integritätsbedingungen richtig umgesetzt werden.
\begin{itemize}

\item Transformation des konzeptionellen Modells in ein relationales Schema.
\item Festlegung von Tabellen, Spalten (Attributen), Primärschlüsseln und Fremdschlüsseln.
\item Definition von Datentypen und Zellkonfigurationen (z. B. NOT NULL, UNIQUE, CHECK).
\end{itemize}

\item
Physisches Datenmodell

Eine physische Datenbankstruktur wird durch \ac{SQL} erstellt, basierend auf dem logischen Entwurf.
Die konkrete Festlegung von Tabellen, Indizes, Constraints usw. erfolgt dabei durch das implementierte System, welches immer wieder getestet und zusammen mit den Nutzerinnen auf fachliche Richtigkeit überprüft wird.
\begin{itemize}

\item Realisierung des logischen Modells in einer spezifischen Datenbankmanagementsoftware (z. B. MySQL, MariaDB oder Microsoft SQL Server).
\item Die Verbesserung der Speicherstrukturen, der Indexierung und der Partitionierung.

\end{itemize}

\item
Implementierung und Prüfung

Nach der erfolgreichen Umsetzung wird das System vom Kunden gemäß einem vorher festgelegten Abnahmeplan freigegeben.
Ein Wartungsplan kümmert sich anschließend um die Betreuung, schult die Endbenutzer und überwacht die IT-Umgebung kontinuierlich.


\begin{itemize}

\item Der Aufbau der Tabellen und Relationen erfolgt entsprechend dem Datenbankschema.

\item Die Testdaten implementieren.

\item Die Kontrolle der Funktionalität und Leistung.

\end{itemize}

\end{enumerate}


\subsubsection{Methoden zum Datenbankzugriff in Flask}

In diesem Abschnitt werden die maßgeblichen Methoden für die Arbeit mit SQL-Datenbanken in Flask vorgestellt, ihre Charakteristika erläutert und ein Vergleich gezogen.
Hier werden zwei der meistgenutzten Ansätze  vorgestellt und Vor-/Nachteilen aufgezeigt.


\textbf{Direkter SQL-Zugriff via DB-Treiber}

\\

Bei dieser Methode wird direkt mit einem Datenbanktreiber (z. B. psycopg2, mariaDB oder mysql-connector) gearbeitet.
SQL-Statements werden als Strings formuliert und über einen Cursor ausgeführt.
Ein Cursor ist ein Steuerobjekt, das SQL-Befehle ausführt und Ergebnisse verwaltet.
Diese Methode eignet sich vorwiegend für kleine Anwendungen oder für hochoptimierte Spezialfälle, bei den abstrakte Ein- und Auslesen-Befehle vorgenommen werden.
Ein typischer Ablauf für diese Methode läuft wie flogt ab: \cite{mysql_connector_python,psycopg2,mariadb_connector_python}

\begin{enumerate}

\item
Der Verbindungsaufbau zu einer Datenbank.
\item
Ausführung eines SQL-Statements durch einen Cursor (z. B. SELECT, INSERT, UPDATE, DELETE).
\item
Abrufen der Resultate und Überführen in eine geeignete Datenstruktur (z. B. eine Liste oder Dictionary).
\item
Schließen der Verbindung nach fertiger Ausführung.

\end{enumerate}

In der folgenden Tabelle \ref{tab:sql_vor_nachteile} werden einige Vor- und Nachteil der Methode aufgeführt.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.47\textwidth}|p{0.47\textwidth}|}
        \hline
        \textbf{Vorteile} & \textbf{Nachteile} \\
        \hline
        Maximale Kontrolle über das ausgeführte SQL &
        Gefahr für SQL-Injections, wenn Parameter nicht sicher gebunden werden \\
        \hline
        Kein Overhead durch zusätzliche Abstraktionsschichten &
        Manuelle Fehleranfälligkeit (z. B. bei Verbindungshandling oder Transaktionen) \\
        \hline
        Nützlich bei komplexen, datenbankspezifischen Abfragen,
        die ein ORM möglicherweise schwer modellieren kann &
        Schwer zu skalieren bei komplexer Domänenlogik \\
        \hline
        \textemdash &
        Geringe Lesbarkeit, insbesondere bei vielen Joins oder Abhängigkeiten \\
        \hline
    \end{tabular}
    \caption{Vor- und Nachteile des direkten SQL-Zugriffs in Flask}
    \label{tab:sql_vor_nachteile}
    \vspace{0.2cm}
    {Quelle: eigene Darstellung}
\end{table}


\textbf{Object-Relational Mapping}

\\

\ac{ORM} eine Methode in der Softwareentwicklung, die es ermöglicht, Objekte aus einer objektorientierten Programmiersprache auf
Tabellen in einer relationalen Datenbank abzubilden, um die Interaktion mit Datenbanken zu erleichtern.
Entwickler müssen keine SQL-Abfragen mehr manuell erstellen.
Sie interagieren einfach mit Objekten in ihrer Programmiersprache,
und das ORM-Tool wandelt dies in die passenden Datenbankoperationen um. \cite{miguelgrinberg_flask_mega_tutorial_db,flask_official_sqlalchemy_pattern}

Eine der am meisten verwendeten Python-Bibliothek für diese Methode ist SQLAlchemy.
SQLAlchemy ist ein umfangreiches Toolkit und \ac{ORM} für relationale Datenbanken.
In Flask nutzt man normalerweise die Erweiterung Flask-SQLAlchemy, die SQLAlchemy in die Kontextstruktur von Flask
integriert und den typischen Boilerplate-Aufwand reduziert.\cite*{flask_sqlalchemy_docs}

Mit Flask-SQLAlchemy definiert man Modelle als Python-Klassen, die automatisch auf Datenbanktabellen abgebildet werden (Declarative Mapping).
Die Objekte dieser Klassen repräsentieren Datensätze, und Operationen daran (z. B. session.add(), session.commit()) generieren hinter den Kulissen passende SQL-Befehle.\cite*{flask_sqlalchemy_docs}

In der folgenden Tabelle \ref{tab:sqlalchemy_vor_nachteile} werden einige Vor- und Nachteil der Methode bzw. SQLAlchemy aufgeführt.
Neben SQLAlchemy gibt es noch einige andere Python-Bibliotheken die \ac{ORM}- nutzen z. B. SQLModel.
Sie ermöglicht es, ein Modell zu definieren, das sowohl als ORM-Klasse als auch als Validierungs- / Datentypklasse (Pydantic) dient\cite*{sqlmodel_docs}.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.47\textwidth}|p{0.47\textwidth}|}
        \hline
        \textbf{Vorteile} & \textbf{Nachteile} \\
        \hline
        ORM-Abstraktion: Arbeiten mit Objekten statt SQL &
        Leicht höhere Komplexität als direkter SQL-Zugriff \\
        \hline
        Automatisches Erstellen und Aktualisieren von Tabellen &
        Performance bei sehr großen Datenmengen leicht geringer \\
        \hline
        Integriert gut in Flask &
        — \\
        \hline
        Kompatibel mit vielen Datenbanken (SQLite, MySQL, PostgreSQL, etc.) &
        — \\
        \hline
    \end{tabular}
    \caption{Vor- und Nachteile der Verwendung von Flask-SQLAlchemy}
    \label{tab:sqlalchemy_vor_nachteile}
    \vspace{0.2cm}
    {\small Quelle: eigene Darstellung}
\end{table}

