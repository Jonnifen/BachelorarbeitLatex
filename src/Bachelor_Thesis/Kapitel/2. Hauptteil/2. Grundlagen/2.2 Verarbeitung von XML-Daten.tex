\subsection{Verarbeitung von XML-Daten}
\label{subsec:verarbeitung-von-xml-daten}
%------------------------------------------------------------------------------------------------------
Dieses Kapitel behandelt einige Grundlegende und für dies Arbeit relevante Aspekte von dem Dokumententype \ac{XML},
da die Messwerte bzw. die Berichte die der Testand generiert im diesem Format vorliegen.


Bei \ac{XML} handelt es sich um eine Auszeichnungssprache, also eine
formale Sprache, die verwendet werden, um die Struktur und Darstellung von Daten oder Texten zu beschreiben \cite*{Neumann2019}.
\ac{XML} wurde entwickelt, um Informationen in einem maschinenlesbaren und strukturierten Format zu speichern und zu übermitteln.
Sie wird hauptsächlich in Bereichen wie Webdiensten, Datenbanken, Konfigurationsdateien eingesetzt.
\ac{XML} ermöglicht die hierarchische Organisation von Informationen in einem strukturierten Aufbau und kann sowohl für Menschen
als auch für Maschinen interpretiert werden.\cite*[4]{PeterBrezany2003}

Das Grundkonzept hinter \ac{XML} war, eine universelle einsetzbare und erweiterbare Sprache zu erschaffen, die von verschiedenen Systemen
unabhängig von deren grundlegenden Technologieansatz genutzt werden kann.
Hierbei ware das angestrebte Ziel Daten in einem einheitlichen Standard zwischen verschiedenen Anwendungen und Plattformen zu speichern und auszutauschen
zu kömmen.\cite*[3-5]{PeterBrezany2003}
%------------------------------------------------------------------------------------------------------
\subsubsection{XML-Strukturaufbau}
%------------------------------------------------------------------------------------------------------
Eine \ac{XML}-Datei beginnt mit Prolog, der die \ac{XML}-Version und die verwendete Zeichencodierung definiert.
In Abbildung \ref{fig:XML Prolog Beispielcode} ist ein häufig genutzter Prolog dargestellt, der auch in den Teststand-Berichten genutzt wird.
Die erste Zeile des Prologs ist die sogenannte XML-Deklaration.
Die XML-Deklaration enthält häufig die Attribute sind version und encoding, jedoch nur das Attribut version ist Pflicht.
Werden auch die anderen notiert, müssen sie in der angegebenen Reihenfolge deklariert werden.
Attribut version Mit version wird die verwendete XML-Version angegeben.
Das Attribut encoding gibt die im Dokument verwendete Zeichenkodierung an, d. h. mit welcher Codierung die Datei gespeichert wird.
Fehlt die Angabe wird als Vorgabe UTF-8 (8-Bit Unicode Transformation Format) verwendet.
Neben der \ac{XML}-Deklaration können im Prolog auch noch Verarbeitungsanweisungen und Verweise auf eine \ac{DTD} deklariert werden,
dies sind jedoch optional und für diese Arbeit nicht weiter relevant.
\cite*[8,9]{Becher2022}

\begin{figure}[H]
\centering
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}[language=XML]
<?xml version="1.0" encoding="UTF-8"?>
\end{lstlisting}
\end{minipage}
\caption{XML Prolog Beispielcode}
\label{fig:XML Prolog Beispielcode}
    {Quelle: eigene Darstellung}
\end{figure}


Der Hauptteil eines \ac{XML}-Dokument besteht aus einer Reihe von Elementen, die durch Tags markiert sind.
Für jedes Element gibt es ein Start- und ein EndTag, welcher das Element beginnt und beendet.
Ein Starttag kann beispielsweise „<NamedesTags>“ so aus, dann würde der dazugehörige Endtag „</NamedesTags>“ so aussehen.
Der entscheidende Unterschied ist hierbei der Schrägstrich beim Endtag.
Der Name des Elementes wird durch den Inhalt der Keiler- und Großer-Zeichen bestimmt, bei diesem Beispiel wäre der Name „NamedesTags“.
Elemente haben einen Inhalt der aus Text, weiteren Elementen oder aus beidem bestehen kann,
wenn Elemente andere Elemente beinhalten werden Sie als Elterelemente und die enthaltenen Elemente oft Kindelemente bezeichnet.
Diese Eigenschaft der Elementente sorg dafür das XML-Datein einer hierarchischen Baumstruktur folgen.
Hierbei wird das oberste Element als Wurzelelement bezeichnet, im Englischen „root element“.\cite*[10-14]{Becher2022}


\begin{figure}[H]
\centering
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}[language=XML]
<buch><!-- Das Element "Buch" enthät 2 Kinderelement-->
  <titel>XML-Grundlagen</titel>
  <autor>Max Mustermann</autor>
</buch>
\end{lstlisting}
\end{minipage}
\caption{XML Elemente Beispielcode}
\label{fig:XML Elemente Beispielcode}
    {Quelle: eigene Darstellung}
\end{figure}

Jedes Element kann neben Inhalt auch beliebig vielen Attributen ausgestattet sein, die zusätzliche Informationen enthalten.
Attribute werden im Start-Tag eines Elements definiert, diese bestehen immer aus einem Attributnamen und einem Wert.
Der Wert wird dabei mit Anführungszeichen deklariert, wie in Abbildung \ref{fig:XML Attribute Beispielcode} gezeigt. \cite*[10-14]{Becher2022}

\begin{figure}[H]
\centering
\begin{minipage}{0.95\textwidth}
\begin{lstlisting}[language=XML]
<buch genre="Lehrbuch">ES</buch>
    <!--Hier ist das Attribute "genre" mit dem Inhat "Lehrbuch"-->
\end{lstlisting}
\end{minipage}
\caption{XML Attribute Beispielcode}
\label{fig:XML Attribute Beispielcode}
    {Quelle: eigene Darstellung}
\end{figure}


Kommentare werden mit den Tags „<!--“ und „-->“ eingefügt und dienen der Dokumentation oder dem Hinweis auf bestimmte Teile des Codes \cite*[10-14]{Becher2022}.
Dies ist für die automatisch generierten Berichte irrelevant, jedoch für das Beschreiben der Beispiele hilfreich.
In Abbildung \ref{fig:XML Elemente Beispielcode} und Abbildung \ref{fig:XML Attribute Beispielcode} werde diese zur Beschreiben verwendet.
Kommentare werden beim Parsen des Dokuments ignoriert, parsen und Paser werden nachfolgenden Kapitel behandelt.
%------------------------------------------------------------------------------------------------------
\subsubsection{Verarbeiten von XML-Dateien}
%------------------------------------------------------------------------------------------------------
In diesem Abschnitt wird eine Zusammenfassung der grundlegenden Methoden und Techniken gegeben,
um \ac{XML}-Dateien mithilfe verschiedener Tools unabhängig von der verwendeten Programmiersprache zu verarbeiten.
Es wird beschrieben, wie man \ac{XML}-Dateien analysiert, modifiziert und überprüft, um sie für verschiedene Zwecke einsatzbereit zu machen.
An Ende des Abschnittes wird jedoch etwas genauer auf Methoden die in Python genutzt werde eingegangen.

\paragraph{XML-Paser}

Der erste Schritt beim verarbeiten einer \ac{XML}-Daten ist das Parsen.
Hierbei wird die \ac{XML}-Datei in ein Programm geladen und in ein Format umgewandelt, das das Programm interpretieren kann.
XML-Paser prüfen hierbei auch die \ac{XML}-Daten auf Korrektheit, also ob die Voralien eingehalten werden und das Dokument vollständig ist.
Dabei wird in nicht-validierte Parser und validierende Paser differenziert.
Der Unterschied besteht dadrin, dass validierte Paser neben der  korrekte Schachtelung und Bezeichnung der Strukturelemente
wie die nicht-validierten Paser auch noch auf eine Vorgabe einer Dokumenttypdefinition oder eines Schemas prüfen.\cite*[10]{Becher2022}

Paser werden verwendet um eine Applikation über eine \ac{API} eine Schnittstelle auf ein \ac{XML}-Dokument zu geben.
Bei \ac{API}s wird in diesem Bereich zwischen zwei Grundtypen unterschieden:\cite*[405]{Becher2022}

Die baumbasierten \ac{API}s lesen über den XML-Parser das XML-Dokument ein,
parst es und erzeugt ein Modell als Baum von Knoten im Arbeitsspeicher.
Auf Grunde der im XML-Dokument vorkommenden Informationseinheiten wird in verschiedene Knotentypen unterschieden.
Das generierte Modell dient der Applikation für die weitere anwendungsspezifische Verarbeitung.
Ein Beispiel für eine baumbasierte \ac{API}s ist \ac{DOM}.

\ac{DOM}ist Ein objektorientiertes Modell, das die Struktur eines XML-Dokuments abbildet.
In der Baumstruktur wird das gesamte Dokument abgebildet, indem jedes Element, Attribut und jeder Text bzw. Inhalt als Knoten gilt.
Das DOM hat den Vorteil, dass es das \ac{XML}-Dokument vollständig im Arbeitsspeicher darstellt, was das Durchsuchen und Bearbeiten des Dokuments erleichtert.
Zudem bittet es eine einfache Schnittstelle bereitstellt, um XML-Daten zu erreichen und zu verändern.
Allerdings benötigt diese Herangehensweise viel Speicherplatz,
da es das gesamte Dokument im Arbeitsspeicher ablegt, was bei großen \ac{XML}-Dokumenten ein Problem darstellen kann.\cite*[413,414]{Becher2022}


Die ereignisbasierten \ac{API}s lesen \ac{XML}-Dokument sequenziell von begin durch
ein und meldet während des Lesens jedes Ereignis durch sogenannte Callbacks an die aufrufende Applikation zurück.
Ein Ereignis ist ein Signal, das Änderungen in dem Markup-Status anzeigt.
Das Bedeutet Ereignise tritten bei Element-Tags, Zeichendaten, Kommentaren, Verarbeitungsanweisungen, sowie bei den Grenzen des Dokumentes auf.
Der Parser sendet hierbei durch die Callbacks eine Mitteilung an die aufrufende Applikation, welche Ereignisse eingetreten sind.
Das Programm, das den Parser aufgerufen hat, muss nun das Ereignis interpretieren und entsprechend reagieren.
Das \ac{XML}-Dokument wird hierbei nicht vollständig im Arbeitsspeicher gespeichert, sondern in Teilen gelesen und bearbeitet.
Deshalb eignen sich ereignisbasierte \ac{API}s besonders gut für die Verarbeitung großer \ac{XML}-Dateien, da dies für eine geringe Arbeitsspeicherbelastung sorgt.
Trotz der Effizienz hinsichtlich des Speicherverbrauchs sind ereignisbasierte \ac{API}s für die Datenmanipulation nicht sonderlich gut geeignet.
Es wird nämlich durch das Teileweise einlesen keine umfassende Dokumentstruktur wie beim aufgebaut Die baumbasierten \ac{API}s,
welches die Manipulation bzw. bearbeitung erschwert.
Ein Beispiel für eine große ereignisbasierte \ac{API} ist \ac{SAX}.
Diese \ac{API} abreitet nach dem oben beschriebenen Prinzip und wurde ursprünglich als Java-\ac{API} entwickelt, inzwischen gibt es \ac{SAX} auch für weiter Sprachen wie
z. B. C++, Perl und Python.\cite*[405]{Becher2022}

\paragraph{Adressierung mit XPath}

Neben dem Einlesen der XML-Datei muss zum verwenden der Daten in dem XML-Dokument navigiert werden, um bestimmt Knoten zu adressieren.
Aus diesem Grund wurde die Abfragesprache XML Path Language kurz XPath entwickelt.
XPath wird hauptsächlich in der Transformationssprache XSLT (eXtensible Stylesheet Language Transformation) eingesetzt, welche XML-Dateien in ander Datenformate umwandeln soll.
Zudem wird XPath in anderen Programmiersprachen wie z.B. JavaScript, C# oder einigen Pythonbibliotheken für die Adressierung von Bestandteilen des XML-Baums verwendet.



\begin{table}
    \centering
    \begin{tabular}{|l|l|X|}
        \toprule
        \textbf{Name} & \textbf{Kurz-Notation} & \textbf{selektierte Knoten} \\
        \midrule
        / & / & Wurzelknoten \\
        child & (nicht notwendig) & direkt untergeordnete
  Knoten (Kindknoten) \\
        self & . & aktuelle Knoten
  (Kontextknoten) \\
        parent & .. & direkt übergeordneter
  Knoten (Elternknoten) \\
        descendant & .// & alle untergeordnete
  Knoten \\
        descendant-or-self &   & alle untergeordnete
  Knoten sowie der aktuelle Knoten \\
        ancestor &   & alle übergeordnete
  Knoten \\
        ancestor-or-self &   & alle übergeordneten
  Knoten sowie der aktuelle Knoten \\
        following &   & alle nachfolgende
  Knoten (ohne Kindknoten) \\
        following-sibling &   & alle nachfolgende
  Knoten (ohne Kindknoten), die den gleichen Elternknoten haben \\
        preceding &   & alle vorangehende
  Knoten (ohne alle Elternknoten) \\
        preceding-sibling &   & alle vorangehende
  Knoten (ohne alle Elternknoten), die den gleichen Elternknoten haben \\
        attribute & @ & Attributknoten \\
        namespace &   & Namensraumknoten \\
        \bottomrule
    \end{tabular}
    \caption{Übersicht über XPath-Achsen}
    \label{tab: Übersicht über XPath-Achsen}
        {Quelle: eigene Darstellung nach Tabelle aus \cite*{XPath2025}}
\end{table}

\paragraph{Pythonbibliotheken für XML-Verarbeitung}
Neben diesen beide großen Beispielen gibt es auch einige kleiner Anbieter mit abgewandelten Methoden,
die jedoch in dem Umfang deutlich kleiner gehalten sind und weniger Funktionen bitten.
Sie basieren aber auf dem gleichen Grundkonzept.

Ein Beispiel dafür wäre ElementTree.
ElementTree ist eine unkomplizierte und minimalistische Python-Bibliothek, die für die Bearbeitung von \ac{XML} genutzt wird.
Sie präsentiert eine Baumstruktur, die das \ac{XML}-Dokument effektiv darstellt und einfache Techniken zum Durchsuchen,
Modifizieren und Erstellen von \ac{XML}-Dokumenten bietet.\cite*{ElementTree2025}

lxml
\pagebreak